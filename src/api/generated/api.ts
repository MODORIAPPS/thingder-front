/* tslint:disable */
/* eslint-disable */
/**
 * 띵더
 * REST API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CheckPinRequest
 */
export interface CheckPinRequest {
    /**
     * 
     * @type {string}
     * @memberof CheckPinRequest
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckPinRequest
     */
    'pin'?: string;
}
/**
 * 
 * @export
 * @interface CheckPinResponse
 */
export interface CheckPinResponse {
    /**
     * 
     * @type {number}
     * @memberof CheckPinResponse
     */
    'expiration'?: number;
    /**
     * 
     * @type {string}
     * @memberof CheckPinResponse
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckPinResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface InsertImage
 */
export interface InsertImage {
    /**
     * 
     * @type {string}
     * @memberof InsertImage
     */
    'src'?: string;
    /**
     * 
     * @type {string}
     * @memberof InsertImage
     */
    'srcSet'?: string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof LoginResponse
     */
    'expiration'?: number;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface MemberElementResponse
 */
export interface MemberElementResponse {
    /**
     * 
     * @type {string}
     * @memberof MemberElementResponse
     */
    'brand'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberElementResponse
     */
    'genCountry'?: string;
    /**
     * 
     * @type {number}
     * @memberof MemberElementResponse
     */
    'genMonth'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemberElementResponse
     */
    'genYear'?: number;
    /**
     * 
     * @type {SelectImage}
     * @memberof MemberElementResponse
     */
    'image'?: SelectImage;
    /**
     * 
     * @type {string}
     * @memberof MemberElementResponse
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberElementResponse
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberElementResponse
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface MemberListResponse
 */
export interface MemberListResponse {
    /**
     * 
     * @type {Array<MemberElementResponse>}
     * @memberof MemberListResponse
     */
    'members'?: Array<MemberElementResponse>;
}
/**
 * 
 * @export
 * @interface MemberResponse
 */
export interface MemberResponse {
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'brand'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'genCountry'?: string;
    /**
     * 
     * @type {number}
     * @memberof MemberResponse
     */
    'genMonth'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemberResponse
     */
    'genYear'?: number;
    /**
     * 
     * @type {Array<SelectImage>}
     * @memberof MemberResponse
     */
    'images'?: Array<SelectImage>;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'story'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface ModelAndView
 */
export interface ModelAndView {
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    'empty'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof ModelAndView
     */
    'model'?: object;
    /**
     * 
     * @type {{ [key: string]: object | undefined; }}
     * @memberof ModelAndView
     */
    'modelMap'?: { [key: string]: object | undefined; };
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    'reference'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    'status'?: ModelAndViewStatusEnum;
    /**
     * 
     * @type {View}
     * @memberof ModelAndView
     */
    'view'?: View;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    'viewName'?: string;
}

export const ModelAndViewStatusEnum = {
    Accepted: 'ACCEPTED',
    AlreadyReported: 'ALREADY_REPORTED',
    BadGateway: 'BAD_GATEWAY',
    BadRequest: 'BAD_REQUEST',
    BandwidthLimitExceeded: 'BANDWIDTH_LIMIT_EXCEEDED',
    Checkpoint: 'CHECKPOINT',
    Conflict: 'CONFLICT',
    Continue: 'CONTINUE',
    Created: 'CREATED',
    DestinationLocked: 'DESTINATION_LOCKED',
    ExpectationFailed: 'EXPECTATION_FAILED',
    FailedDependency: 'FAILED_DEPENDENCY',
    Forbidden: 'FORBIDDEN',
    Found: 'FOUND',
    GatewayTimeout: 'GATEWAY_TIMEOUT',
    Gone: 'GONE',
    HttpVersionNotSupported: 'HTTP_VERSION_NOT_SUPPORTED',
    ImUsed: 'IM_USED',
    InsufficientSpaceOnResource: 'INSUFFICIENT_SPACE_ON_RESOURCE',
    InsufficientStorage: 'INSUFFICIENT_STORAGE',
    InternalServerError: 'INTERNAL_SERVER_ERROR',
    IAmATeapot: 'I_AM_A_TEAPOT',
    LengthRequired: 'LENGTH_REQUIRED',
    Locked: 'LOCKED',
    LoopDetected: 'LOOP_DETECTED',
    MethodFailure: 'METHOD_FAILURE',
    MethodNotAllowed: 'METHOD_NOT_ALLOWED',
    MovedPermanently: 'MOVED_PERMANENTLY',
    MovedTemporarily: 'MOVED_TEMPORARILY',
    MultipleChoices: 'MULTIPLE_CHOICES',
    MultiStatus: 'MULTI_STATUS',
    NetworkAuthenticationRequired: 'NETWORK_AUTHENTICATION_REQUIRED',
    NonAuthoritativeInformation: 'NON_AUTHORITATIVE_INFORMATION',
    NotAcceptable: 'NOT_ACCEPTABLE',
    NotExtended: 'NOT_EXTENDED',
    NotFound: 'NOT_FOUND',
    NotImplemented: 'NOT_IMPLEMENTED',
    NotModified: 'NOT_MODIFIED',
    NoContent: 'NO_CONTENT',
    Ok: 'OK',
    PartialContent: 'PARTIAL_CONTENT',
    PayloadTooLarge: 'PAYLOAD_TOO_LARGE',
    PaymentRequired: 'PAYMENT_REQUIRED',
    PermanentRedirect: 'PERMANENT_REDIRECT',
    PreconditionFailed: 'PRECONDITION_FAILED',
    PreconditionRequired: 'PRECONDITION_REQUIRED',
    Processing: 'PROCESSING',
    ProxyAuthenticationRequired: 'PROXY_AUTHENTICATION_REQUIRED',
    RequestedRangeNotSatisfiable: 'REQUESTED_RANGE_NOT_SATISFIABLE',
    RequestEntityTooLarge: 'REQUEST_ENTITY_TOO_LARGE',
    RequestHeaderFieldsTooLarge: 'REQUEST_HEADER_FIELDS_TOO_LARGE',
    RequestTimeout: 'REQUEST_TIMEOUT',
    RequestUriTooLong: 'REQUEST_URI_TOO_LONG',
    ResetContent: 'RESET_CONTENT',
    SeeOther: 'SEE_OTHER',
    ServiceUnavailable: 'SERVICE_UNAVAILABLE',
    SwitchingProtocols: 'SWITCHING_PROTOCOLS',
    TemporaryRedirect: 'TEMPORARY_REDIRECT',
    TooEarly: 'TOO_EARLY',
    TooManyRequests: 'TOO_MANY_REQUESTS',
    Unauthorized: 'UNAUTHORIZED',
    UnavailableForLegalReasons: 'UNAVAILABLE_FOR_LEGAL_REASONS',
    UnprocessableEntity: 'UNPROCESSABLE_ENTITY',
    UnsupportedMediaType: 'UNSUPPORTED_MEDIA_TYPE',
    UpgradeRequired: 'UPGRADE_REQUIRED',
    UriTooLong: 'URI_TOO_LONG',
    UseProxy: 'USE_PROXY',
    VariantAlsoNegotiates: 'VARIANT_ALSO_NEGOTIATES'
} as const;

export type ModelAndViewStatusEnum = typeof ModelAndViewStatusEnum[keyof typeof ModelAndViewStatusEnum];

/**
 * 
 * @export
 * @interface PickRequest
 */
export interface PickRequest {
    /**
     * 
     * @type {string}
     * @memberof PickRequest
     */
    'relation'?: PickRequestRelationEnum;
    /**
     * 
     * @type {string}
     * @memberof PickRequest
     */
    'uid'?: string;
}

export const PickRequestRelationEnum = {
    Block: 'BLOCK',
    Dislike: 'DISLIKE',
    Like: 'LIKE'
} as const;

export type PickRequestRelationEnum = typeof PickRequestRelationEnum[keyof typeof PickRequestRelationEnum];

/**
 * 
 * @export
 * @interface PickResponse
 */
export interface PickResponse {
    /**
     * 
     * @type {boolean}
     * @memberof PickResponse
     */
    'match'?: boolean;
    /**
     * 
     * @type {MemberResponse}
     * @memberof PickResponse
     */
    'member'?: MemberResponse;
}
/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'brand'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'genCountry'?: string;
    /**
     * 
     * @type {number}
     * @memberof RegisterRequest
     */
    'genMonth'?: number;
    /**
     * 
     * @type {number}
     * @memberof RegisterRequest
     */
    'genYear'?: number;
    /**
     * 
     * @type {Array<InsertImage>}
     * @memberof RegisterRequest
     */
    'images'?: Array<InsertImage>;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'pinToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'story'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface RegisterResponse
 */
export interface RegisterResponse {
    /**
     * 
     * @type {string}
     * @memberof RegisterResponse
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof RegisterResponse
     */
    'expiration'?: number;
    /**
     * 
     * @type {string}
     * @memberof RegisterResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof Resource
     */
    'file'?: File;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'filename'?: string;
    /**
     * 
     * @type {object}
     * @memberof Resource
     */
    'inputStream'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof Resource
     */
    'open'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Resource
     */
    'readable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface SelectImage
 */
export interface SelectImage {
    /**
     * 
     * @type {string}
     * @memberof SelectImage
     */
    'src'?: string;
    /**
     * 
     * @type {string}
     * @memberof SelectImage
     */
    'srcSet'?: string;
    /**
     * 
     * @type {string}
     * @memberof SelectImage
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface SendPinResponse
 */
export interface SendPinResponse {
    /**
     * 
     * @type {string}
     * @memberof SendPinResponse
     */
    'expireAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof SendPinResponse
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface UploadImageResponse
 */
export interface UploadImageResponse {
    /**
     * 
     * @type {string}
     * @memberof UploadImageResponse
     */
    'src'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadImageResponse
     */
    'srcSet'?: string;
}
/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'contentType'?: string;
}

/**
 * AuthControllerApi - axios parameter creator
 * @export
 */
export const AuthControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checkPin
         * @param {CheckPinRequest} [checkPinRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPinUsingPOST: async (checkPinRequest?: CheckPinRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/pin/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkPinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUsingPOST: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary my
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary register
         * @param {RegisterRequest} [registerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUsingPOST: async (registerRequest?: RegisterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sendPin
         * @param {string} phone phone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPinUsingPOST: async (phone: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'phone' is not null or undefined
            assertParamExists('sendPinUsingPOST', 'phone', phone)
            const localVarPath = `/auth/pin/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (phone !== undefined) {
                localVarQueryParameter['phone'] = phone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary checkPin
         * @param {CheckPinRequest} [checkPinRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkPinUsingPOST(checkPinRequest?: CheckPinRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckPinResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkPinUsingPOST(checkPinRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUsingPOST(loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUsingPOST(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary my
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.myUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary register
         * @param {RegisterRequest} [registerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUsingPOST(registerRequest?: RegisterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUsingPOST(registerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary sendPin
         * @param {string} phone phone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPinUsingPOST(phone: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendPinResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPinUsingPOST(phone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary checkPin
         * @param {CheckPinRequest} [checkPinRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPinUsingPOST(checkPinRequest?: CheckPinRequest, options?: any): AxiosPromise<CheckPinResponse> {
            return localVarFp.checkPinUsingPOST(checkPinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUsingPOST(loginRequest?: LoginRequest, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.loginUsingPOST(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary my
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myUsingGET(options?: any): AxiosPromise<void> {
            return localVarFp.myUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary register
         * @param {RegisterRequest} [registerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUsingPOST(registerRequest?: RegisterRequest, options?: any): AxiosPromise<RegisterResponse> {
            return localVarFp.registerUsingPOST(registerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary sendPin
         * @param {string} phone phone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPinUsingPOST(phone: string, options?: any): AxiosPromise<SendPinResponse> {
            return localVarFp.sendPinUsingPOST(phone, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi extends BaseAPI {
    /**
     * 
     * @summary checkPin
     * @param {CheckPinRequest} [checkPinRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public checkPinUsingPOST(checkPinRequest?: CheckPinRequest, options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).checkPinUsingPOST(checkPinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary login
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public loginUsingPOST(loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).loginUsingPOST(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary my
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public myUsingGET(options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).myUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary register
     * @param {RegisterRequest} [registerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public registerUsingPOST(registerRequest?: RegisterRequest, options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).registerUsingPOST(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary sendPin
     * @param {string} phone phone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public sendPinUsingPOST(phone: string, options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).sendPinUsingPOST(phone, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BasicErrorControllerApi - axios parameter creator
 * @export
 */
export const BasicErrorControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingTRACE: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'TRACE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasicErrorControllerApi - functional programming interface
 * @export
 */
export const BasicErrorControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BasicErrorControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingDELETE(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingDELETE(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingHEAD(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingHEAD(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingOPTIONS(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingOPTIONS(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingPATCH(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingPATCH(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingPOST(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingPOST(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingPUT(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingPUT(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingTRACE(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingTRACE(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BasicErrorControllerApi - factory interface
 * @export
 */
export const BasicErrorControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BasicErrorControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingDELETE(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingHEAD(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingOPTIONS(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingPATCH(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingPOST(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingPUT(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingTRACE(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingTRACE(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BasicErrorControllerApi - object-oriented interface
 * @export
 * @class BasicErrorControllerApi
 * @extends {BaseAPI}
 */
export class BasicErrorControllerApi extends BaseAPI {
    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingDELETE(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingDELETE(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingGET(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingHEAD(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingHEAD(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingOPTIONS(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingOPTIONS(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPATCH(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPATCH(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPOST(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPUT(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPUT(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingTRACE(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingTRACE(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImageControllerApi - axios parameter creator
 * @export
 */
export const ImageControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getImageFileByPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageFileByPathUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image/**`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary uploadImage
         * @param {File} file file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadImageUsingPOST: async (file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadImageUsingPOST', 'file', file)
            const localVarPath = `/image/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageControllerApi - functional programming interface
 * @export
 */
export const ImageControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary getImageFileByPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageFileByPathUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageFileByPathUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary uploadImage
         * @param {File} file file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadImageUsingPOST(file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadImageUsingPOST(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImageControllerApi - factory interface
 * @export
 */
export const ImageControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary getImageFileByPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageFileByPathUsingGET(options?: any): AxiosPromise<Resource> {
            return localVarFp.getImageFileByPathUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary uploadImage
         * @param {File} file file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadImageUsingPOST(file: File, options?: any): AxiosPromise<UploadImageResponse> {
            return localVarFp.uploadImageUsingPOST(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageControllerApi - object-oriented interface
 * @export
 * @class ImageControllerApi
 * @extends {BaseAPI}
 */
export class ImageControllerApi extends BaseAPI {
    /**
     * 
     * @summary getImageFileByPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageControllerApi
     */
    public getImageFileByPathUsingGET(options?: AxiosRequestConfig) {
        return ImageControllerApiFp(this.configuration).getImageFileByPathUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary uploadImage
     * @param {File} file file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageControllerApi
     */
    public uploadImageUsingPOST(file: File, options?: AxiosRequestConfig) {
        return ImageControllerApiFp(this.configuration).uploadImageUsingPOST(file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MatchingControllerApi - axios parameter creator
 * @export
 */
export const MatchingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary findList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findListUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/matching/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary pick
         * @param {PickRequest} [pickRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pickUsingPOST: async (pickRequest?: PickRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/matching/pick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchingControllerApi - functional programming interface
 * @export
 */
export const MatchingControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchingControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary findList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findListUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findListUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary pick
         * @param {PickRequest} [pickRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pickUsingPOST(pickRequest?: PickRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pickUsingPOST(pickRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MatchingControllerApi - factory interface
 * @export
 */
export const MatchingControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchingControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary findList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findListUsingGET(options?: any): AxiosPromise<MemberListResponse> {
            return localVarFp.findListUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary pick
         * @param {PickRequest} [pickRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pickUsingPOST(pickRequest?: PickRequest, options?: any): AxiosPromise<PickResponse> {
            return localVarFp.pickUsingPOST(pickRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MatchingControllerApi - object-oriented interface
 * @export
 * @class MatchingControllerApi
 * @extends {BaseAPI}
 */
export class MatchingControllerApi extends BaseAPI {
    /**
     * 
     * @summary findList
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingControllerApi
     */
    public findListUsingGET(options?: AxiosRequestConfig) {
        return MatchingControllerApiFp(this.configuration).findListUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary pick
     * @param {PickRequest} [pickRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingControllerApi
     */
    public pickUsingPOST(pickRequest?: PickRequest, options?: AxiosRequestConfig) {
        return MatchingControllerApiFp(this.configuration).pickUsingPOST(pickRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MemberControllerApi - axios parameter creator
 * @export
 */
export const MemberControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/member/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary find
         * @param {string} memberUid memberUid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsingGET: async (memberUid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberUid' is not null or undefined
            assertParamExists('findUsingGET', 'memberUid', memberUid)
            const localVarPath = `/member/{memberUid}`
                .replace(`{${"memberUid"}}`, encodeURIComponent(String(memberUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MemberControllerApi - functional programming interface
 * @export
 */
export const MemberControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MemberControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsingDELETE(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsingDELETE(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary find
         * @param {string} memberUid memberUid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUsingGET(memberUid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUsingGET(memberUid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MemberControllerApi - factory interface
 * @export
 */
export const MemberControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MemberControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE(options?: any): AxiosPromise<void> {
            return localVarFp.deleteUsingDELETE(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary find
         * @param {string} memberUid memberUid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsingGET(memberUid: string, options?: any): AxiosPromise<MemberResponse> {
            return localVarFp.findUsingGET(memberUid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MemberControllerApi - object-oriented interface
 * @export
 * @class MemberControllerApi
 * @extends {BaseAPI}
 */
export class MemberControllerApi extends BaseAPI {
    /**
     * 
     * @summary delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberControllerApi
     */
    public deleteUsingDELETE(options?: AxiosRequestConfig) {
        return MemberControllerApiFp(this.configuration).deleteUsingDELETE(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary find
     * @param {string} memberUid memberUid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberControllerApi
     */
    public findUsingGET(memberUid: string, options?: AxiosRequestConfig) {
        return MemberControllerApiFp(this.configuration).findUsingGET(memberUid, options).then((request) => request(this.axios, this.basePath));
    }
}


